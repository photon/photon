<?php
/* -*- tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
/*
# ***** BEGIN LICENSE BLOCK *****
# This file is part of Photon, the High Speed PHP Framework.
# Copyright (C) 2010, 2011 Loic d'Anterroches and contributors.
#
# Photon is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License.
#
# Photon is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# ***** END LICENSE BLOCK ***** */

/**
 * Photon Templating Engine.
 *
 * The templating engine is very small and directly reuse the PHP
 * parser. A template is compiled as a PHP file and provides a class
 * with a render() method.
 */
namespace photon\template;

use photon\config\Container as Conf;
use photon\template\compiler\Compiler as Compiler;

class Exception extends \Exception {};

/**
 * Render a template file.
 */
class Renderer
{
    public $tpl = '';
    public $folders = array();
    public $cache = '';
    public $compiled_template = '';
    public $template_content = '';
    public $context = null;
    public $class = '';
    public $compiler = null;

    /**
     * Constructor.
     *
     * If the folder names are not provided, default to
     * Conf::f('template_folders', null)
     * If the cache folder name is not provided, it will default to
     * Conf::f('tmp_folder', '/tmp')
     *
     * @param string Template name.
     * @param string Template folder paths (null)
     * @param string Cache folder name (null)
     * @param $options Extra options for the compiler (array())
     */
    function __construct($template, $folders=null, $cache=null, $options=array())
    {
        $this->tpl = $template;
        $this->folders = (null === $folders) 
            ? Conf::f('template_folders') : $folders;
        $this->cache = (null === $cache)
            ? Conf::f('tmp_folder') : $cache;

        list($tmpl_path, $tmpl_uid) = $this->getCompiledTemplateName();
        $this->compiled_template = $tmpl_path;
        $this->class = 'Template_' . $tmpl_uid;

        if (!\Phar::running() &&
            !class_exists('\photon\template\compiled\\' . $this->class, false)) {
            if (!file_exists($this->compiled_template) || Conf::f('debug')  
                || Conf::f('template_force_compilation')) {
                $this->compiler = new Compiler($this->tpl, $this->folders, $options);
                $this->getCompiledTemplateContent();
                $this->write($this->compiled_template);
            }
            include_once $this->compiled_template;
        }
    }

    /**
     * Render the template with the given context and return the content.
     *
     * @param $c Object Context (null)
     */
    function render($c=null)
    {
        $this->context = (null === $c) ? new Context() : $c;
        ob_start();
        try {
            call_user_func(array('\photon\template\compiled\\' . $this->class, 
                                 'render'), $this->context);
        } catch (\Exception $e) {
            ob_clean();
            throw $e;
        }
        $a = ob_get_contents();
        ob_end_clean();

        return $a;
    }

    /**
     * Get the full name of the compiled template.
     *
     * Ends with .phps to prevent execution from outside if the cache folder
     * is not secured but to still have the syntax higlightings by the tools
     * for debugging.
     *
     * @return string Full path to the compiled template
     */
    function getCompiledTemplateName()
    {
        // The compiled template not only depends on the file but also
        // on the possible folders in which it can be found.
        $uid = md5($this->tpl);

        return array($this->cache . '/photon_template_compiled_' . $uid . '.phps', 
                     $uid);
    }

    /**
     * Run the compiler and get the content.
     */
    function getCompiledTemplateContent()
    {
        // We wrap the raw PHP in the right class, with the right
        // namespace etc. We need to also load the localization
        // classes.
        $content = $this->compiler->getCompiledTemplate();
        $this->template_content = '<?php
// Automatically generated by Photon at: ' . date('c') . '
// Photon - http://photon-project.com
// Source Templates: 
';
        foreach ($this->compiler->sourceFiles as $src) {
            $this->template_content .= '//  ' . $src . "\n";
        }
        $this->template_content .= 'namespace photon\template\compiled;
class ' . $this->class . '
{
    public static function render($t) 
    {
        ?>' . $content . '<?php 
    } 
}';
    }

    /**
     * Write the compiled template in the cache folder.
     * Throw an exception if it cannot write it.
     *
     * @param $file Where to write the template
     * @return bool Success in writing
     */
    function write($file) 
    {
        if (false === @file_put_contents($file, $this->template_content, LOCK_EX)) {
            throw new Exception(sprintf(__('Cannot write the compiled template: %s'), $file));
        }

        return true;
    }

    public static function markSafe($string)
    {
        return new SafeString($string, true);
    }

    /**
     * Safely echo an object/string in the template.
     *
     * @param $mixed
     * @return void
     */
    public static function secho($mixed)
    {
        echo (!is_object($mixed) || 'photon\template\SafeString' != get_class($mixed)) ?
            htmlspecialchars($mixed) : $mixed->value;
    }

    /**
     * Safely return an object/string in the template.
     *
     * @param $mixed
     * @return string String safe to display in an HTML page
     */
    public static function sreturn($mixed)
    {
        return (!is_object($mixed) || 'photon\template\SafeString' != get_class($mixed)) ?
            htmlspecialchars($mixed) : $mixed->value;
    }
}

/**
 * A string already escaped to display in a template.
 */
class SafeString
{
    public $value = '';

    function __construct($mixed, $safe=false)
    {
        if (is_object($mixed) and 'photon\template\SafeString' == get_class($mixed)) {
            $this->value = $mixed->value;
        } else {
            $this->value = ($safe) ? $mixed : htmlspecialchars($mixed);
        }
    }

    function __toString()
    {
        return $this->value;
    }

    public static function markSafe($string)
    {
        return new SafeString($string, true);
    }
}

/**
 * Class storing the data that are then used in the template.
 */
class Context 
{
    public $_vars;

    public function __construct($vars=array())
    {
        $this->_vars = new ContextVars($vars);
    }

    public function get($var)
    {
        if (isset($this->_vars[$var])) {

            return $this->_vars[$var];
        }

        return '';
    }

    public function set($var, $value)
    {
        $this->_vars[$var] = $value;
    }
}

/**
 * Class storing the data that are then used in the template.
 */
class ContextRequest extends Context
{
    public function __construct($request, $vars=array())
    {
        $vars = array_merge(array('request' => $request), $vars);
        foreach (Conf::f('template_context_processors', array()) as $proc) {
            $vars = array_merge(call_user_func($proc, $request), $vars); 
        }
        $this->_vars = new ContextVars($vars);
    }
}

/**
 * Special array where the keyed indexes can be accessed as properties.
 */
class ContextVars extends \ArrayObject
{
    function __get($prop)
    {
        return (isset($this[$prop])) ? $this[$prop] : '';
    }

    function __set($prop, $value)
    {
        $this[$prop] = $value;
    }

    function __toString()
    {
        return var_export($this, true);
    }
}

/**
 * Default modifiers for the compilers.
 *
 * Each modifier is a static method.
 */
class Modifier
{
    /**
     * Set a string to be safe for display.
     *
     * @param $string String to be safe for display.
     * @return SafeString 
     */
    public static function safe($string)
    {
        return new SafeString($string, true);
    }

    /**
     * New line to <br /> returning a safe string.
     *
     * @param $mixed Input
     * @return string Safe to display in HTML.
     */
    public static function nl2br($mixed)
    {
        if (!is_object($mixed) || 'photon\template\SafeString' !== get_class($mixed)) {
            return Renderer::markSafe(\nl2br(htmlspecialchars($mixed)));
        } else {

            return Renderer::markSafe(\nl2br((string) $mixed));
        }
    }

    /**
     * Var export returning a safe string.
     *
     * @param mixed Input
     * @return string Safe to display in HTML.
     */
    public static function varExport($mixed)
    {
        return self::safe('<pre>' . esc(var_export($mixed, true)) . '</pre>');
    }


    /**
     * Hex encode an email excluding the "mailto:".
     */
    public static function safeEmail($email)
    {
        $email = chunk_split(bin2hex($email), 2, '%');
        $email = '%' . substr($email, 0, strlen($email) - 1);

        return self::safe($email);
    }

    /**
     * Returns the first item in the given array.
     *
     * @param array $array
     * @return mixed An empty string if $array is not an array.
     */
    public static function first($array)
    {
        $array = (array) $array;
        $result = \array_shift($array);

        return (null === $result) ? '' : $result;
    }

    /**
     * Returns the last item in the given array.
     *
     * @param array $array
     * @return mixed An empty string if $array is not an array.
     */
    public static function last($array)
    {
        $array = (array) $array;
        $result = \array_pop($array);

        return (null === $result) ? '' : $result;
    }
}

/**
 * Escape a string in a binary safe way.
 *
 * htmlspecialchars will break if you pass in a badly encoded
 * string. This escaping function will not break.
 */
function esc($string) 
{
    return \str_replace(array('&',     '"',      '<',    '>'),
                        array('&amp;', '&quot;', '&lt;', '&gt;'),
                        (string) $string);
}


/**
 * Special htmlspecialchars that can handle the objects.
 *
 * @param string String proceeded by htmlspecialchars
 * @return string String like if htmlspecialchars was not applied
 */
function htmlspecialchars($string)
{
    return \htmlspecialchars((string) $string, ENT_COMPAT, 'UTF-8');
}


